spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

server.port=8080

#Needed to connect to config server to read property files
#spring.application.name=Must match name of config files wherever they are being stored
#spring.profiles.active=Specifying which version of config files you want to use whether it is prod or dev etc
#spring.config.import=url where configserver is located to gain access to config files, port number is specified within config server properties file
spring.application.name=accounts
spring.profiles.active=prod
spring.config.import=optional:configserver:http://localhost:8071
#In order to refresh config properties without restarting service, we need the refresh property on the actuator and by default that is blocked so we need to tell Spring to give us access to all those actuator endpoints in order to do that config refresh
management.endpoints.web.exposure.include=*

#In order to do the config refresh, you call http://localhost:8080/actuator/refresh in postman *Does not work with props like db info since that requires a server restart
#Also, if you have 100 instances, you need a script or docker compose command to do this action with all 100 instances

#Needed for Eureka discovery service
eureka.instance.preferIpAddress = true
eureka.client.registerWithEureka = true
eureka.client.fetchRegistry = true
eureka.client.serviceUrl.defaultZone = http://localhost:8070/eureka/

#Configuring info endpoint
info.app.name=Accounts Microservice
info.app.description=Eazy Bank Accounts Application
info.app.version=1.0.0
management.info.env.enabled = true

#Needed to enable shutdown api for microservice through rest call
endpoints.shutdown.enabled=true
management.endpoint.shutdown.enabled=true
manaagement.endpoint.env.enabled=true

#Needed for circuit breaker pattern in order to allow default behavior in case of non-working microservices
resilience4j.circuitbreaker.configs.default.registerHealthIndicator= true
resilience4j.circuitbreaker.instances.defaultCustomerDetails.minimumNumberOfCalls= 5
resilience4j.circuitbreaker.instances.defaultCustomerDetails.failureRateThreshold= 50
resilience4j.circuitbreaker.instances.defaultCustomerDetails.waitDurationInOpenState= 30000
resilience4j.circuitbreaker.instances.defaultCustomerDetails.permittedNumberOfCallsInHalfOpenState=2

#Needed for retry pattern
resilience4j.retry.instances.retryForCustomerDetails.max-attempts=3
resilience4j.retry.instances.retryForCustomerDetails.waitDuration=2000

#Needed for rate limiter pattern - sayHello is name of method
resilience4j.ratelimiter.configs.default.registerHealthIndicator= true
resilience4j.ratelimiter.instances.sayHello.timeoutDuration=5000
resilience4j.ratelimiter.instances.sayHello.limitRefreshPeriod=5000
resilience4j.ratelimiter.instances.sayHello.limitForPeriod=1


